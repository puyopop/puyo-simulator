# コーディングプラクティス

## 原則

### 関数型アプローチ (FP)

- 純粋関数を優先
- 不変データ構造を使用
- 副作用を分離
- 型安全性を確保

### ドメイン駆動設計 (DDD)

- 値オブジェクトとエンティティを区別
- 集約で整合性を保証
- リポジトリでデータアクセスを抽象化
- 境界付けられたコンテキストを意識

### テスト駆動開発 (TDD)

- Red-Green-Refactorサイクル
- テストを仕様として扱う
- 小さな単位で反復
- 継続的なリファクタリング

## 実装パターン

### 型定義

```typescript
// ブランデッド型で型安全性を確保
type Branded<T, B> = T & { _brand: B };
type Money = Branded<number, "Money">;
type Email = Branded<string, "Email">;
```

### 値オブジェクト

- 不変
- 値に基づく同一性
- 自己検証
- ドメイン操作を持つ

```typescript
// 作成関数はバリデーション付き
function createMoney(amount: number): Result<Money, Error> {
  if (amount < 0) return err(new Error("負の金額不可"));
  return ok(amount as Money);
}
```

### エンティティ

- IDに基づく同一性
- 制御された更新
- 整合性ルールを持つ

### Result型

```typescript
type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };
```

- 成功/失敗を明示
- 早期リターンパターンを使用
- エラー型を定義

### リポジトリ

- ドメインモデルのみを扱う
- 永続化の詳細を隠蔽
- テスト用のインメモリ実装を提供

### アダプターパターン

- 外部依存を抽象化
- インターフェースは呼び出し側で定義
- テスト時は容易に差し替え可能

## 実装手順

1. **型設計**
   - まず型を定義
   - ドメインの言語を型で表現

2. **純粋関数から実装**
   - 外部依存のない関数を先に
   - テストを先に書く

3. **副作用を分離**
   - IO操作は関数の境界に押し出す
   - 副作用を持つ処理をPromiseでラップ

4. **アダプター実装**
   - 外部サービスやDBへのアクセスを抽象化
   - テスト用モックを用意

## プラクティス

- 小さく始めて段階的に拡張
- 過度な抽象化を避ける
- コードよりも型を重視
- 複雑さに応じてアプローチを調整

## コードスタイル

- 関数優先（クラスは必要な場合のみ）
- 不変更新パターンの活用
- 早期リターンで条件分岐をフラット化
- エラーとユースケースの列挙型定義

## テスト戦略

- 純粋関数の単体テストを優先
- インメモリ実装によるリポジトリテスト
- テスト可能性を設計に組み込む
- アサートファースト：期待結果から逆算

## Deno の使い方について

### npm 互換モード

私は Deno の Node 互換APIが使えます。

npm のライブラリを参照できる。`npm:zod` のように npm
からライブラリを参照します。

### 外部ライブラリの使用方法

deno 用のライブラリは多くないので、ユーザーから指定されない限りは node
互換APIを優先します。

例外的に、以下のURLは node より Deno 互換を優先して使用します。

- `jsr:@david/dax`: コマンドランナー
- `jsr:@std/expect`: アサーション
- `jsr:@std/testing`: テストフレームワーク

コードを書き始めるにあたって `docs/libraries/*`
の下に該当するドキュメントがある場合、ライブラリを使用する前に、これを読み込みます。

docs/librarise にドキュメントが存在しないとき

- `jsr:` の場合、 `deno doc jsr:@scope/pkgName`
  で、ライブラリ基本的なAPIをを確認します。
- `npm:` の場合、`npm-summary pkgName`
  でライブラリの要約を確認することができます。

ライブラリを追加するとき、 deno.json にすでに import
されていないか確認します。存在しない場合、 `deno add ...` で追加してください

### ソースコード内のモジュールの参照方法

自分のディレクトリ以外のソースコードを確認する時は、 `deno doc ../foo/mod.ts`
のように型定義だけを確認する。

### テストの書き方

`@std/expect` と `@std/testing/bdd` を使う。 とくに実装上の理由がない限り、
`describe` による入れ子はしない。

```ts
import { expect } from "@std/expect";
import { test } from "@std/testing/bdd";

test("2+3=5", () => {
  expect(add(2, 3), "sum of numbers").toBe(5);
});
```

アサーションの書き方

- `expect(result, "<expected behavior>").toBe("result")`
  で可能な限り期待する動作を書く

### モジュール間の依存関係

### import ルール

- モジュール間の参照は必ず mod.ts を経由する